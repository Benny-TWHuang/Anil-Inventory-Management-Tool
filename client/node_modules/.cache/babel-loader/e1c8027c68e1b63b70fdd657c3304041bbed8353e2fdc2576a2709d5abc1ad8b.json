{"ast":null,"code":"let IDX = 36;\nlet HEX = \"\";\nwhile (IDX--) {\n  HEX += IDX.toString(36);\n}\nfunction uid() {\n  let len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 11;\n  let str = \"\";\n  let num = len;\n  while (num--) {\n    str += HEX[Math.random() * 36 | 0];\n  }\n  return str;\n}\nconst escapeRegexp = term => term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, char => `\\\\${char}`);\nconst termsToRegExpString = terms => {\n  return terms.replace(/\\s{2,}/g, \" \").split(\" \").join(\"|\");\n};\nconst regexpQuery = _ref => {\n  let {\n    terms,\n    matchExactly = false\n  } = _ref;\n  if (typeof terms !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n  const escapedTerms = escapeRegexp(terms.trim());\n  return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;\n};\nconst buildRegexp = _ref2 => {\n  let {\n    terms,\n    matchExactly = false\n  } = _ref2;\n  try {\n    const fromString = /^([/~@;%#'])(.*?)\\1([gimsuy]*)$/.exec(terms);\n    if (fromString) {\n      return new RegExp(fromString[2], fromString[3]);\n    }\n    return new RegExp(regexpQuery({\n      terms,\n      matchExactly\n    }), \"ig\");\n  } catch (e) {\n    throw new TypeError(\"Expected terms to be either a string or a RegExp!\");\n  }\n};\nconst hasProp = prop => obj => obj !== null && typeof obj !== \"undefined\" && prop in obj;\nconst hasMatch = hasProp(\"match\");\nconst chunkExists = chunk => typeof chunk !== \"undefined\";\nfunction clip(_ref3) {\n  let {\n    curr,\n    next,\n    prev,\n    clipBy = 3\n  } = _ref3;\n  const words = curr.text.split(\" \");\n  const len = words.length;\n  if (curr.match || clipBy >= len) {\n    return curr.text;\n  }\n  const ellipsis = \"...\";\n  if (chunkExists(next) && chunkExists(prev) && hasMatch(prev) && hasMatch(next)) {\n    if (len > clipBy * 2) {\n      return [...words.slice(0, clipBy), ellipsis, ...words.slice(-clipBy)].join(\" \");\n    }\n    return curr.text;\n  }\n  if (chunkExists(next) && hasMatch(next)) {\n    return [ellipsis, ...words.slice(-clipBy)].join(\" \");\n  }\n  if (chunkExists(prev) && hasMatch(prev)) {\n    return [...words.slice(0, clipBy), ellipsis].join(\" \");\n  }\n  return curr.text;\n}\nvar __assign = Object.assign;\nconst hasLength = str => str.length > 0;\nconst highlightWords = _ref4 => {\n  let {\n    text,\n    query,\n    clipBy,\n    matchExactly = false\n  } = _ref4;\n  const safeQuery = typeof query === \"string\" ? query.trim() : query;\n  if (safeQuery === \"\") {\n    return [{\n      key: uid(),\n      text,\n      match: false\n    }];\n  }\n  const searchRegexp = buildRegexp({\n    terms: query,\n    matchExactly\n  });\n  return text.split(searchRegexp).filter(hasLength).map(str => ({\n    key: uid(),\n    text: str,\n    match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)\n  })).map((chunk, index, chunks) => __assign(__assign({}, chunk), typeof clipBy === \"number\" && {\n    text: clip(__assign(__assign(__assign({\n      curr: chunk\n    }, index < chunks.length - 1 && {\n      next: chunks[index + 1]\n    }), index > 0 && {\n      prev: chunks[index - 1]\n    }), {\n      clipBy\n    }))\n  }));\n};\nexport default highlightWords;","map":{"version":3,"names":["IDX","HEX","toString","uid","len","str","num","Math","random","escapeRegexp","term","replace","char","termsToRegExpString","terms","split","join","regexpQuery","matchExactly","TypeError","escapedTerms","trim","buildRegexp","fromString","exec","RegExp","e","hasProp","prop","obj","hasMatch","chunkExists","chunk","clip","curr","next","prev","clipBy","words","text","length","match","ellipsis","slice","__assign","Object","assign","hasLength","highlightWords","query","safeQuery","key","searchRegexp","filter","map","toLowerCase","test","index","chunks"],"sources":["/home/test/Desktop/Anil-Inventory-Management-Tool/client/node_modules/highlight-words/dist/highlight-words.mjs"],"sourcesContent":["let IDX = 36;\nlet HEX = \"\";\nwhile (IDX--) {\n  HEX += IDX.toString(36);\n}\nfunction uid(len = 11) {\n  let str = \"\";\n  let num = len;\n  while (num--) {\n    str += HEX[Math.random() * 36 | 0];\n  }\n  return str;\n}\n\nconst escapeRegexp = (term) => term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, (char) => `\\\\${char}`);\nconst termsToRegExpString = (terms) => {\n  return terms.replace(/\\s{2,}/g, \" \").split(\" \").join(\"|\");\n};\nconst regexpQuery = ({\n  terms,\n  matchExactly = false\n}) => {\n  if (typeof terms !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n  const escapedTerms = escapeRegexp(terms.trim());\n  return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;\n};\nconst buildRegexp = ({\n  terms,\n  matchExactly = false\n}) => {\n  try {\n    const fromString = /^([/~@;%#'])(.*?)\\1([gimsuy]*)$/.exec(terms);\n    if (fromString) {\n      return new RegExp(fromString[2], fromString[3]);\n    }\n    return new RegExp(regexpQuery({terms, matchExactly}), \"ig\");\n  } catch (e) {\n    throw new TypeError(\"Expected terms to be either a string or a RegExp!\");\n  }\n};\n\nconst hasProp = (prop) => (obj) => obj !== null && typeof obj !== \"undefined\" && prop in obj;\nconst hasMatch = hasProp(\"match\");\nconst chunkExists = (chunk) => typeof chunk !== \"undefined\";\nfunction clip({\n  curr,\n  next,\n  prev,\n  clipBy = 3\n}) {\n  const words = curr.text.split(\" \");\n  const len = words.length;\n  if (curr.match || clipBy >= len) {\n    return curr.text;\n  }\n  const ellipsis = \"...\";\n  if (chunkExists(next) && chunkExists(prev) && hasMatch(prev) && hasMatch(next)) {\n    if (len > clipBy * 2) {\n      return [\n        ...words.slice(0, clipBy),\n        ellipsis,\n        ...words.slice(-clipBy)\n      ].join(\" \");\n    }\n    return curr.text;\n  }\n  if (chunkExists(next) && hasMatch(next)) {\n    return [ellipsis, ...words.slice(-clipBy)].join(\" \");\n  }\n  if (chunkExists(prev) && hasMatch(prev)) {\n    return [...words.slice(0, clipBy), ellipsis].join(\" \");\n  }\n  return curr.text;\n}\n\nvar __assign = Object.assign;\nconst hasLength = (str) => str.length > 0;\nconst highlightWords = ({\n  text,\n  query,\n  clipBy,\n  matchExactly = false\n}) => {\n  const safeQuery = typeof query === \"string\" ? query.trim() : query;\n  if (safeQuery === \"\") {\n    return [\n      {\n        key: uid(),\n        text,\n        match: false\n      }\n    ];\n  }\n  const searchRegexp = buildRegexp({terms: query, matchExactly});\n  return text.split(searchRegexp).filter(hasLength).map((str) => ({\n    key: uid(),\n    text: str,\n    match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)\n  })).map((chunk, index, chunks) => __assign(__assign({}, chunk), typeof clipBy === \"number\" && {\n    text: clip(__assign(__assign(__assign({\n      curr: chunk\n    }, index < chunks.length - 1 && {next: chunks[index + 1]}), index > 0 && {prev: chunks[index - 1]}), {\n      clipBy\n    }))\n  }));\n};\n\nexport default highlightWords;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}